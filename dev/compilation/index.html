<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Compilation · YaoLang.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">YaoLang.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Compilation</a><ul class="internal"><li><a class="tocitem" href="#Representation-1"><span>Representation</span></a></li><li><a class="tocitem" href="#Compiler-API-References-1"><span>Compiler API References</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Compilation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Compilation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuantumBFS/YaoLang.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Compilation-1"><a class="docs-heading-anchor" href="#Compilation-1">Compilation</a><a class="docs-heading-anchor-permalink" href="#Compilation-1" title="Permalink"></a></h1><p>The compilation framework of YaoLang is designed to be highly extensible, so one can easily extend the semantics as long as there is no ambiguity.</p><p>For simple code generation task, one can use Julia native macros directly instead of writing a custom compiler pass. But for more complicated task, one would prefer to add a custom compiler pass.</p><h2 id="Representation-1"><a class="docs-heading-anchor" href="#Representation-1">Representation</a><a class="docs-heading-anchor-permalink" href="#Representation-1" title="Permalink"></a></h2><p><code>YaoLang</code> is a domain specific language, it embeds its own representation inside the Julia AST and SSA IR.</p><p>The Julia AST captured by a macro <a href="#YaoLang.Compiler.@device"><code>@device</code></a> will be first transformed into custom function calls tagged with <code>GlobalRef(YaoLang.Compiler, :node_name)</code>. The syntax check will then check if the syntax is correct, then the AST will be compiled into Julia&#39;s SSA IR as a <code>CodeInfo</code> object.</p><p>Then we transform the <code>CodeInfo</code> object to a quantum SSA IR by inferring the quantum statements, where we call this representation as <a href="#YaoLang.Compiler.YaoIR"><code>YaoIR</code></a>.</p><h3 id="YaoIR-1"><a class="docs-heading-anchor" href="#YaoIR-1">YaoIR</a><a class="docs-heading-anchor-permalink" href="#YaoIR-1" title="Permalink"></a></h3><p>The Yao IR annotates our domain specific semantics using a <code>:quantum</code> head, followed by a custom head, such as <code>:gate</code>. For example, <code>1 =&gt; X</code> will be parsed as <code>Expr(:quantum, :gate, :X, 1)</code>.</p><h2 id="Compiler-API-References-1"><a class="docs-heading-anchor" href="#Compiler-API-References-1">Compiler API References</a><a class="docs-heading-anchor-permalink" href="#Compiler-API-References-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.YaoIR" href="#YaoLang.Compiler.YaoIR"><code>YaoLang.Compiler.YaoIR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">YaoIR</code></pre><p>The Yao Intermediate Representation. See compilation section for more details.</p><pre><code class="language-none">YaoIR([m::Module=YaoLang.Compiler], ast::Expr)</code></pre><p>Creates a <code>YaoIR</code> from Julia AST.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.is_qasm_compatible-Tuple{IRTools.Inner.IR}" href="#YaoLang.Compiler.is_qasm_compatible-Tuple{IRTools.Inner.IR}"><code>YaoLang.Compiler.is_qasm_compatible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_qasm_compatible(ir)</code></pre><p>Check if the given expression is compatible with openQASM.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.is_quantum-Tuple{IRTools.Inner.Statement}" href="#YaoLang.Compiler.is_quantum-Tuple{IRTools.Inner.Statement}"><code>YaoLang.Compiler.is_quantum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_quantum(ex)</code></pre><p>Check if the given expression is a quantum statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ZXCalculus.gate_count-Tuple{GenericCircuit}" href="#ZXCalculus.gate_count-Tuple{GenericCircuit}"><code>ZXCalculus.gate_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gate_count(circuit)::Dict</code></pre><p>Count the number of each primitive instructions in given pure quantum circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.@code_yao-Tuple{Any}" href="#YaoLang.Compiler.@code_yao-Tuple{Any}"><code>YaoLang.Compiler.@code_yao</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@code_yao &lt;generic circuit call&gt;</code></pre><p>Evaluates the arguments to the function call, determines their types, and calls <code>code_yao</code> on the resulting expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.@ctrl" href="#YaoLang.Compiler.@ctrl"><code>YaoLang.Compiler.@ctrl</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@ctrl k &lt;gate location&gt;</code></pre><p>Keyword for controlled gates in quantum circuit. It must be used inside <code>@device</code>. See also <a href="#YaoLang.Compiler.@device"><code>@device</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.@device" href="#YaoLang.Compiler.@device"><code>YaoLang.Compiler.@device</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@device [options] &lt;generic circuit definition&gt;</code></pre><p>Entry for defining a generic quantum program. A generic quantum program is a function takes a set of classical arguments as input and return a quantum program that can be furthur compiled into pulses or other quantum instructions. The quantum program can return classical values from device if <code>return</code> statement is declared explicitly, or it always return nothing, and mutates the quantum register.</p><p><strong>Supported Semantics</strong></p><ul><li><a href="#YaoLang.Compiler.@ctrl"><code>@ctrl</code></a>: Keyword for controlled gates in quantum circuit.</li><li><a href="#YaoLang.Compiler.@measure"><code>@measure</code></a>: Keyword for measurement in quantum circuit.</li></ul><p>The function marked by <code>@device</code> can be multiple dispatched like other Julia function. The only difference is that it always returns a quantum circuit object that should be runable on quantum device by feeding it the location of qubits and the pointer to quantum register.</p><p><strong>Options</strong></p><ul><li><code>target</code>, compilation target, default is <code>:julia</code>, see <strong>Compilation Targets</strong> for details.</li></ul><p><strong>Compilation Targets</strong></p><ul><li><code>:julia</code>, default target, compiles the program to Julia program.</li><li><code>:qasm</code>, compiles the program to <a href="https://github.com/Qiskit/openqasm">openQASM</a>.</li></ul><p><strong>Example</strong></p><p>We can define a Quantum Fourier Transformation in the following recursive way</p><pre><code class="language-julia">@device function qft(n::Int)
    1 =&gt; H
    for k in 2:n
        @ctrl k 1=&gt;shift(2π/2^k)
    end

    if n &gt; 1
        2:n =&gt; qft(n-1)
    end
end</code></pre><p>This will give us a generic quantum circuit <code>qft</code> with 1 method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.@measure" href="#YaoLang.Compiler.@measure"><code>YaoLang.Compiler.@measure</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@measure &lt;location&gt; [operator] [configuration]</code></pre><p>Keyword for measurement in quantum circuit. It must be used inside <code>@device</code>. See also <a href="#YaoLang.Compiler.@device"><code>@device</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>&lt;location&gt;</code>: a valid <code>Locations</code> argument to specifiy where to measure the register</li><li><code>[operator]</code>: Optional, specifiy which operator to measure</li><li><code>[configuration]</code>: Optional, it can be either:<ul><li><code>remove=true</code> will remove the measured qubits</li><li><code>reset_to=&lt;bitstring&gt;</code> will reset the measured qubits to given bitstring</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.@primitive-Tuple{Any}" href="#YaoLang.Compiler.@primitive-Tuple{Any}"><code>YaoLang.Compiler.@primitive</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@primitive ex</code></pre><p>Define a primitive quantum instruction. <code>ex</code> can be a Symbol, if the corresponding instruction interface of <code>YaoAPI.instruct!</code> is implemented. Or <code>ex</code> can be an assignment statement for constant instructions. Or <code>ex</code> can be a function that returns corresponding matrix given a set of classical parameters.</p><p><strong>Example</strong></p><p>Since the instructions interface <code>YaoAPI.instruct!</code> of Pauli operators are defined, we can use</p><pre><code class="language-julia">@primitive X</code></pre><p>to declare a Pauli X primitive instruction.</p><p>Or we can also define a Hadamard primitive instruction via its matrix form</p><pre><code class="language-julia">@primitive H = [1 1;1 -1]/sqrt(2)</code></pre><p>For parameterized gates, such as phase shift gate, we can define it as</p><pre><code class="language-julia">@primitive shift(θ::Real) = Diagonal([1.0, exp(im * θ)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.@quantum-Tuple{Int64,Any}" href="#YaoLang.Compiler.@quantum-Tuple{Int64,Any}"><code>YaoLang.Compiler.@quantum</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@quantum nqubits::Int &lt;generic circuit call&gt;</code></pre><p>Partially evaluate all classical parts of the generic circuit.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The classical part of the program could result in different circuits if it is not deterministic.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.generate_forward_stub-Tuple{Symbol,Any}" href="#YaoLang.Compiler.generate_forward_stub-Tuple{Symbol,Any}"><code>YaoLang.Compiler.generate_forward_stub</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generate_forward_stub(name::Symbol, op)</code></pre><p>Generate forward stub which forward primitive circuit to instruction interfaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.mark_quantum-Tuple{IRTools.Inner.IR}" href="#YaoLang.Compiler.mark_quantum-Tuple{IRTools.Inner.IR}"><code>YaoLang.Compiler.mark_quantum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mark_quantum(ir::IR)</code></pre><p>swap the statement tag with <code>:quantum</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.rm_annotations-Tuple{Any}" href="#YaoLang.Compiler.rm_annotations-Tuple{Any}"><code>YaoLang.Compiler.rm_annotations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rm_annotations(x)</code></pre><p>Remove type annotation of given expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 22 September 2020 01:16">Tuesday 22 September 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
